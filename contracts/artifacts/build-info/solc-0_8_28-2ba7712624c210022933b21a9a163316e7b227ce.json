{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-2ba7712624c210022933b21a9a163316e7b227ce",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/ArenaVaultV2.sol": "project/contracts/ArenaVaultV2.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@pythnetwork/pyth-sdk-solidity/=npm/@pythnetwork/pyth-sdk-solidity@3.1.0/",
        "project/:@pythnetwork/pyth-sdk-solidity/=npm/@pythnetwork/pyth-sdk-solidity@3.1.0/"
      ]
    },
    "sources": {
      "npm/@pythnetwork/pyth-sdk-solidity@3.1.0/IPyth.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./PythStructs.sol\";\nimport \"./IPythEvents.sol\";\n\n/// @title Consume prices from the Pyth Network (https://pyth.network/).\n/// @dev Please refer to the guidance at https://docs.pyth.network/documentation/pythnet-price-feeds/best-practices for how to consume prices safely.\n/// @author Pyth Data Association\ninterface IPyth is IPythEvents {\n    /// @notice Returns the period (in seconds) that a price feed is considered valid since its publish time\n    function getValidTimePeriod() external view returns (uint validTimePeriod);\n\n    /// @notice Returns the price and confidence interval.\n    /// @dev Reverts if the price has not been updated within the last `getValidTimePeriod()` seconds.\n    /// @param id The Pyth Price Feed ID of which to fetch the price and confidence interval.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPrice(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price and confidence interval.\n    /// @dev Reverts if the EMA price is not available.\n    /// @param id The Pyth Price Feed ID of which to fetch the EMA price and confidence interval.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPrice(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the price of a price feed without any sanity checks.\n    /// @dev This function returns the most recent price update in this contract without any recency checks.\n    /// This function is unsafe as the returned price update may be arbitrarily far in the past.\n    ///\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\n    /// sufficiently recent for their application. If you are considering using this function, it may be\n    /// safer / easier to use either `getPrice` or `getPriceNoOlderThan`.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPriceUnsafe(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the price that is no older than `age` seconds of the current time.\n    /// @dev This function is a sanity-checked version of `getPriceUnsafe` which is useful in\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\n    /// recently.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price of a price feed without any sanity checks.\n    /// @dev This function returns the same price as `getEmaPrice` in the case where the price is available.\n    /// However, if the price is not recent this function returns the latest available price.\n    ///\n    /// The returned price can be from arbitrarily far in the past; this function makes no guarantees that\n    /// the returned price is recent or useful for any particular application.\n    ///\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\n    /// sufficiently recent for their application. If you are considering using this function, it may be\n    /// safer / easier to use either `getEmaPrice` or `getEmaPriceNoOlderThan`.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPriceUnsafe(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price that is no older than `age` seconds\n    /// of the current time.\n    /// @dev This function is a sanity-checked version of `getEmaPriceUnsafe` which is useful in\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\n    /// recently.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Update price feeds with given update messages.\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    /// Prices will be updated if they are more recent than the current stored prices.\n    /// The call will succeed even if the update is not the most recent.\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid.\n    /// @param updateData Array of price update data.\n    function updatePriceFeeds(bytes[] calldata updateData) external payable;\n\n    /// @notice Wrapper around updatePriceFeeds that rejects fast if a price update is not necessary. A price update is\n    /// necessary if the current on-chain publishTime is older than the given publishTime. It relies solely on the\n    /// given `publishTimes` for the price feeds and does not read the actual price update publish time within `updateData`.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    ///\n    /// `priceIds` and `publishTimes` are two arrays with the same size that correspond to senders known publishTime\n    /// of each priceId when calling this method. If all of price feeds within `priceIds` have updated and have\n    /// a newer or equal publish time than the given publish time, it will reject the transaction to save gas.\n    /// Otherwise, it calls updatePriceFeeds method to update the prices.\n    ///\n    /// @dev Reverts if update is not needed or the transferred fee is not sufficient or the updateData is invalid.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param publishTimes Array of publishTimes. `publishTimes[i]` corresponds to known `publishTime` of `priceIds[i]`\n    function updatePriceFeedsIfNecessary(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64[] calldata publishTimes\n    ) external payable;\n\n    /// @notice Returns the required fee to update an array of price updates.\n    /// @param updateData Array of price update data.\n    /// @return feeAmount The required fee in Wei.\n    function getUpdateFee(\n        bytes[] calldata updateData\n    ) external view returns (uint feeAmount);\n\n    /// @notice Parse `updateData` and return price feeds of the given `priceIds` if they are all published\n    /// within `minPublishTime` and `maxPublishTime`.\n    ///\n    /// You can use this method if you want to use a Pyth price at a fixed time and not the most recent price;\n    /// otherwise, please consider using `updatePriceFeeds`. This method may store the price updates on-chain, if they\n    /// are more recent than the current stored prices.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    ///\n    ///\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\n    /// no update for any of the given `priceIds` within the given time range.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.\n    /// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\n    function parsePriceFeedUpdates(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime\n    ) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);\n\n    /// @notice Similar to `parsePriceFeedUpdates` but ensures the updates returned are\n    /// the first updates published in minPublishTime. That is, if there are multiple updates for a given timestamp,\n    /// this method will return the first update. This method may store the price updates on-chain, if they\n    /// are more recent than the current stored prices.\n    ///\n    ///\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\n    /// no update for any of the given `priceIds` within the given time range and uniqueness condition.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.\n    /// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\n    function parsePriceFeedUpdatesUnique(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime\n    ) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);\n}\n"
      },
      "npm/@pythnetwork/pyth-sdk-solidity@3.1.0/IPythEvents.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @title IPythEvents contains the events that Pyth contract emits.\n/// @dev This interface can be used for listening to the updates for off-chain and testing purposes.\ninterface IPythEvents {\n    /// @dev Emitted when the price feed with `id` has received a fresh update.\n    /// @param id The Pyth Price Feed ID.\n    /// @param publishTime Publish time of the given price update.\n    /// @param price Price of the given price update.\n    /// @param conf Confidence interval of the given price update.\n    event PriceFeedUpdate(\n        bytes32 indexed id,\n        uint64 publishTime,\n        int64 price,\n        uint64 conf\n    );\n}\n"
      },
      "npm/@pythnetwork/pyth-sdk-solidity@3.1.0/PythStructs.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\ncontract PythStructs {\n    // A price with a degree of uncertainty, represented as a price +- a confidence interval.\n    //\n    // The confidence interval roughly corresponds to the standard error of a normal distribution.\n    // Both the price and confidence are stored in a fixed-point numeric representation,\n    // `x * (10^expo)`, where `expo` is the exponent.\n    //\n    // Please refer to the documentation at https://docs.pyth.network/documentation/pythnet-price-feeds/best-practices for how\n    // to how this price safely.\n    struct Price {\n        // Price\n        int64 price;\n        // Confidence interval around the price\n        uint64 conf;\n        // Price exponent\n        int32 expo;\n        // Unix timestamp describing when the price was published\n        uint publishTime;\n    }\n\n    // PriceFeed represents a current aggregate price from pyth publisher feeds.\n    struct PriceFeed {\n        // The price ID.\n        bytes32 id;\n        // Latest available price\n        Price price;\n        // Latest available exponentially-weighted moving average price\n        Price emaPrice;\n    }\n}\n"
      },
      "project/contracts/ArenaVaultV2.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"@pythnetwork/pyth-sdk-solidity/IPyth.sol\";\nimport \"@pythnetwork/pyth-sdk-solidity/PythStructs.sol\";\n\n/**\n * @title ArenaVault V2 - Server-Driven Architecture\n * @dev Single-player prediction battles resolved by orchestration server\n * @notice This contract is designed for Pyth hackathon compliance with automated resolution\n */\ncontract ArenaVaultV2 {\n    IPyth public pyth;\n    address public owner;\n    address public resolver; // The orchestration server wallet\n\n    struct Battle {\n        address player;\n        uint256 prediction; // Price prediction in Pyth format (price * 10^8)\n        bool isHigher; // true = predicts price will go up, false = down\n        uint256 stake;\n        uint256 startTime;\n        uint256 duration;\n        bool resolved;\n        int64 finalPrice;\n        address winner;\n        uint256 createdAt;\n    }\n\n    struct LuckyGame {\n        string gameId; // Server-generated ID\n        address player;\n        uint256 entryFee;\n        uint256 guess;\n        uint256 minRange;\n        uint256 maxRange;\n        uint256 randomNumber;\n        bool resolved;\n        bool winner; // true if player won, false if lost\n        uint256 createdAt;\n        uint256 expiresAt;\n    }\n\n    Battle[] public battles;\n    mapping(string => LuckyGame) public luckyGames;\n    string[] public luckyGameIds;\n\n    // Events\n    event BattleCreated(uint256 indexed battleId, address indexed player, uint256 prediction, bool isHigher, uint256 stake, uint256 duration);\n    event BattleResolved(uint256 indexed battleId, address indexed winner, int64 finalPrice);\n    event LuckyGameCreated(string indexed gameId, address indexed player, uint256 entryFee, uint256 guess);\n    event LuckyGameResolved(string indexed gameId, address indexed player, uint256 randomNumber, bool winner);\n    event ResolverUpdated(address indexed oldResolver, address indexed newResolver);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not the owner\");\n        _;\n    }\n\n    modifier onlyResolver() {\n        require(msg.sender == resolver, \"Not authorized resolver\");\n        _;\n    }\n\n    constructor(address _pythAddress, address /* _entropyAddress */) {\n        pyth = IPyth(_pythAddress);\n        owner = msg.sender;\n        resolver = msg.sender; // Initially owner, can be updated\n    }\n\n    /**\n     * @dev Set the resolver address (orchestration server)\n     * @param _resolver Address of the orchestration server\n     */\n    function setResolver(address _resolver) external onlyOwner {\n        address oldResolver = resolver;\n        resolver = _resolver;\n        emit ResolverUpdated(oldResolver, _resolver);\n    }\n\n    /**\n     * @dev Create a single-player prediction battle\n     * @param _prediction Price prediction in Pyth format\n     * @param _isHigher True if predicting price will go up\n     * @param _duration Battle duration in seconds\n     */\n    function createBattle(uint256 _prediction, bool _isHigher, uint256 _duration) external payable {\n        require(msg.value > 0, \"Stake required\");\n        require(_duration >= 60, \"Minimum 1 minute duration\");\n        require(_duration <= 3600, \"Maximum 1 hour duration\");\n\n        uint256 battleId = battles.length;\n        \n        battles.push(Battle({\n            player: msg.sender,\n            prediction: _prediction,\n            isHigher: _isHigher,\n            stake: msg.value,\n            startTime: block.timestamp,\n            duration: _duration,\n            resolved: false,\n            finalPrice: 0,\n            winner: address(0),\n            createdAt: block.timestamp\n        }));\n\n        emit BattleCreated(battleId, msg.sender, _prediction, _isHigher, msg.value, _duration);\n    }\n\n    /**\n     * @dev Resolve a battle (only callable by resolver/server)\n     * @param battleId ID of the battle to resolve\n     * @param priceUpdateData Pyth price update data from Hermes\n     */\n    function resolveBattle(uint256 battleId, bytes[] calldata priceUpdateData)\n        external\n        payable\n        onlyResolver\n    {\n        require(battleId < battles.length, \"Battle does not exist\");\n        Battle storage battle = battles[battleId];\n        require(!battle.resolved, \"Already resolved\");\n        require(block.timestamp >= battle.startTime + battle.duration, \"Battle not expired\");\n\n        // Update Pyth prices with provided data and pay fee\n        uint fee = pyth.getUpdateFee(priceUpdateData);\n        require(msg.value >= fee, \"Insufficient Pyth fee\");\n        pyth.updatePriceFeeds{value: fee}(priceUpdateData);\n\n        // Get ETH/USD price after update\n        bytes32 priceID = 0xff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace;\n        PythStructs.Price memory price = pyth.getPrice(priceID);\n        battle.finalPrice = price.price;\n\n        // Determine winner based on prediction\n        bool predictionCorrect = false;\n        if (battle.isHigher && price.price > int64(int256(battle.prediction))) {\n            predictionCorrect = true;\n        } else if (!battle.isHigher && price.price < int64(int256(battle.prediction))) {\n            predictionCorrect = true;\n        }\n\n        if (predictionCorrect) {\n            battle.winner = battle.player;\n            // Player wins 2x their stake (original stake + profit)\n            payable(battle.player).transfer(battle.stake * 2);\n        } else {\n            battle.winner = address(0); // House wins\n            // Stake goes to contract (house)\n        }\n\n        battle.resolved = true;\n\n        // Refund excess Pyth fee to resolver\n        if (msg.value > fee) {\n            payable(msg.sender).transfer(msg.value - fee);\n        }\n\n        emit BattleResolved(battleId, battle.winner, battle.finalPrice);\n    }\n\n    /**\n     * @dev Create a lucky game (server-managed)\n     * @param _gameId Server-generated unique game ID\n     * @param _player Player address\n     * @param _guess Player's guess\n     * @param _minRange Minimum range value\n     * @param _maxRange Maximum range value\n     * @param _expiresAt Expiration timestamp\n     */\n    function createLuckyGame(\n        string calldata _gameId,\n        address _player,\n        uint256 _guess,\n        uint256 _minRange,\n        uint256 _maxRange,\n        uint256 _expiresAt\n    ) external payable onlyResolver {\n        require(bytes(_gameId).length > 0, \"Invalid game ID\");\n        require(_player != address(0), \"Invalid player address\");\n        require(_guess >= _minRange && _guess <= _maxRange, \"Guess out of range\");\n        require(_expiresAt > block.timestamp, \"Invalid expiration\");\n        require(bytes(luckyGames[_gameId].gameId).length == 0, \"Game ID already exists\");\n\n        luckyGames[_gameId] = LuckyGame({\n            gameId: _gameId,\n            player: _player,\n            entryFee: msg.value,\n            guess: _guess,\n            minRange: _minRange,\n            maxRange: _maxRange,\n            randomNumber: 0,\n            resolved: false,\n            winner: false,\n            createdAt: block.timestamp,\n            expiresAt: _expiresAt\n        });\n\n        luckyGameIds.push(_gameId);\n\n        emit LuckyGameCreated(_gameId, _player, msg.value, _guess);\n    }\n\n    /**\n     * @dev Resolve a lucky game (only callable by resolver/server)\n     * @param _gameId Game ID to resolve\n     * @param _randomNumber Generated random number\n     */\n    function resolveLuckyGame(string calldata _gameId, uint256 _randomNumber) \n        external \n        onlyResolver \n    {\n        LuckyGame storage game = luckyGames[_gameId];\n        require(bytes(game.gameId).length > 0, \"Game does not exist\");\n        require(!game.resolved, \"Already resolved\");\n        require(block.timestamp >= game.expiresAt, \"Game not expired\");\n\n        // Normalize random number to range\n        uint256 range = game.maxRange - game.minRange + 1;\n        uint256 winningNumber = game.minRange + (_randomNumber % range);\n        game.randomNumber = winningNumber;\n\n        // Check if player won (exact match)\n        if (game.guess == winningNumber) {\n            game.winner = true;\n            // Player wins 2x their entry fee\n            payable(game.player).transfer(game.entryFee * 2);\n        } else {\n            game.winner = false;\n            // Entry fee goes to house\n        }\n\n        game.resolved = true;\n\n        emit LuckyGameResolved(_gameId, game.player, winningNumber, game.winner);\n    }\n\n    /**\n     * @dev Get all battles\n     */\n    function getAllBattles() external view returns (Battle[] memory) {\n        return battles;\n    }\n\n    /**\n     * @dev Get battle count\n     */\n    function getBattleCount() external view returns (uint256) {\n        return battles.length;\n    }\n\n    /**\n     * @dev Get lucky game by ID\n     */\n    function getLuckyGame(string calldata _gameId) external view returns (LuckyGame memory) {\n        require(bytes(luckyGames[_gameId].gameId).length > 0, \"Game does not exist\");\n        return luckyGames[_gameId];\n    }\n\n    /**\n     * @dev Get all lucky game IDs\n     */\n    function getAllLuckyGameIds() external view returns (string[] memory) {\n        return luckyGameIds;\n    }\n\n    /**\n     * @dev Get lucky game count\n     */\n    function getLuckyGameCount() external view returns (uint256) {\n        return luckyGameIds.length;\n    }\n\n    /**\n     * @dev Check if battle is expired\n     */\n    function isBattleExpired(uint256 battleId) external view returns (bool) {\n        require(battleId < battles.length, \"Battle does not exist\");\n        Battle storage battle = battles[battleId];\n        return block.timestamp >= battle.startTime + battle.duration;\n    }\n\n    /**\n     * @dev Check if lucky game is expired\n     */\n    function isLuckyGameExpired(string calldata _gameId) external view returns (bool) {\n        require(bytes(luckyGames[_gameId].gameId).length > 0, \"Game does not exist\");\n        return block.timestamp >= luckyGames[_gameId].expiresAt;\n    }\n\n    /**\n     * @dev Emergency withdraw (owner only)\n     */\n    function emergencyWithdraw() external onlyOwner {\n        payable(owner).transfer(address(this).balance);\n    }\n\n    /**\n     * @dev Get contract balance\n     */\n    function getBalance() external view returns (uint256) {\n        return address(this).balance;\n    }\n\n    /**\n     * @dev Receive function to accept ETH\n     */\n    receive() external payable {}\n\n    /**\n     * @dev Fallback function\n     */\n    fallback() external payable {}\n}\n"
      }
    }
  }
}